#What is \*nix anyway?

Unix and GNU and Linux... what are all of these things? 

Since we aren't really doing history and have little desire to wade into the ideological battles fought within the communities, for our sake, all we really need to know is that they are operating systems.

Yup. That's it. Really. Just like Windows, Android, iOS, and pretty much any interface you've used to interact with computer is an operating system. It is the thing that mediates between you and the computer/device.

#Why do I care?

Well... you don't really have to. Not really. 

But. As information professionals who spend a great deal of our time promoting and ensuring access to shared resources, these operating systems do have a conceptual quality that is appealing. They are free and/or open source software. Now... one of the main people behind GNU would get super mad at me for call GNU open source, but whatever. He isn't here (thankfully).

Again, I could get into the difference between 'free' and 'open source' but it isn't really important at the moment. The more important distinction is the difference between \*nix operating systems and proprietary ones like Windows. And this difference is about what you can do with the software. \*nix places significantly fewer restrictions on what you can do with the software vs. what you are allowed to do with Windows or similar systems. 

In a word, using \*nix gives you more freedom. And this is something that, as information professionals, we ought to care a great deal about. 

#Okay... but what _really_ is the difference?

Sure. The above is a lot of high-minded idealism but what are the practical differences?

For me... The thing that is most appealing about using \*nix, and I've been using Linux as my main operating system for two or three years now, is my ability to tweak my computing environment to best suit my individual needs. 

A small example. I hate icons. Like... a lot. My brain works in a certain way that, in general, prevents me from processing visual information as efficiently or readily as textual information. I don't have a visual memory so icons can get super frustrating for me since I often just don't know what they mean or represent. This has become increasingly more true as modern design veers towards more and more abstract representations of functions. 

On Linux, though, I can change one desktop setting to remove all icons and replace them with text instead. It is a small change... but one that makes my computing environment a lot more friendly and useful to me. 

This type of variety and choice is really apparent when you delve into just how many different kinds of linux desktop distributions (distros) their are. Anyone is able to take the basic operating system and make their own thing, if they want. And I think this is pretty cool, since you really can pick something that suits you and your needs best, rather than having to change your habits and self to work within 'one-size-fits-all' operating system.

#Wait. When are you going to talk about the commandline?

Now! :D

The commandline isn't a defining feature of \*nix. I mean... in the getting set up portion, we can see that you can use a commandline interface (CLI) in Windows, OSX, and \*nix.

So what is it and why would we bother?

Depending on how old you are, you might remember using DOS as your main operating system. This was also a commandline interface.

The better way for me to really get into this is to talk about how the 'desktop' is actually a metaphor. I mean... this seems obvious when you think about it, but our 'desktop' computer and the actual desktop it rests on aren't the same. Like at all. We actually use a great deal of metaphors when interacting with our computers: files, folders, windows, etc. All of these things are ways to understand and, yes, visualize what our computer is doing.

They also are an abstraction from the actual computer. This is one way to understand the power and utility of Graphic User Interfaces (GUI). The create a level of abstraction that allowed a great deal many more people to understand and work with computers than was possible before their widespread adoption. And it isn't just about the visual element, since the metaphorical linking of (invisible) abstract computer operations to concrete, real world objects helps a lot for understanding. We know what a file is. We also know what it means for a file to be ina folder. We know this because we can take physical paper files and put them in manila folders. 

The CLI removes part of the abstraction and allows you to interact with your computer in a different way (while still relying on some of the same metaphors, since the concept of a 'file' doesn't disappear in the CLI but we more often tend to talk about directories instead of 'folders' -- even as they represent the same concept).

Again... this is a lot of words to say that the CLI is text-based (generally speaking) and GUIs are image-based (generally speaking).  

#Ugh. But _why_ would I bother with the CLI?

Some people will tell you that the CLI is more 'powerful' (whatever that means). And certainly, those people who use it are often called 'power users', but I don't find this a very helpful way to understand the usefulness of the CLI.

In fact, it can be rather intimidating since, as we know from Spiderman "with great power comes great responsibility". Maybe you don't want that much power (and thus potential to mess up your computer). 

It also doesn't accurately describe the situation. Depending on what you are doing using the CLI or GUI might present the easiest option. I mean... as much as I love the CLI and spend a lot of time using it, I still find it much, much quicker to transfer a single file by dragging and dropping it, rather than typing out the command. 

So when do I use CLI? To take from above... I might use it if I wanted to move a bunch of files but rename them at the same time since there is not easy, quick way to do something like this using a GUI. And, why, you might ask, would you ever need to move and rename a batch of files?

Well... I don't know about you, but my digital camera automatically names my pictures. And the names.... leave a lot to be desired, since they rarely capture any useful metadata about the images beyond the date. So maybe I want to move a set of images from my digital camera's memory and onto my hard-drive, but rename them all with the place, date, and give them a numerical sequence... This is the sort of thing that you can do with one command, making it easier than the multistep process that you'd need in most GUIs. 

And this is the sort of thing that you'll hopefully learn how to do in this workshop. More importantly, if we do this workshop correctly, you'll leave not only with some new skills for using a CLI, but you'll have a better understanding of when using the CLI might be better than a GUI and vice versa.
